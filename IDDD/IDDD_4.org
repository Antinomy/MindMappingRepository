* 架构
不需要特定的架构，选择架构是为了减少风险，而不增加风险。
** 分层
Layers Architecture
*** 严格
Strict Layers Architecture
*** 松散
Relaxed Layers Architecture
**** 允许耦合
***** 观察者
Observer
***** 调停者
Mediator
*** 依赖倒置原则（DIP）
Dependency Inversion Principle 
**** 抽象不应该依赖细节
**** 细节应该依赖抽象
** 六边形架构
Hexagonal Architecture, 端口与适配器
*** 特点
**** 对称平等,持久生命力
**** 非前后端,而是内外区域
**** 一个客户一个适配器
*** 基础架构
**** 支撑其他架构
(SOA,REST,CQRS...)
** SOA
面向服务架构(Service-Oriented Architecture)
*** 服务设计原则
**** 契约
通过契约文档,阐述自身的目的和功能.
**** 松耦合
依赖最小化
**** 抽象
只发布契约,隐藏内部逻辑
**** 重用性
可被其他服务重用
**** 自治性
自行控制环境与资源，以保持独立性
**** 无状态性
**** 可发现性
可通过元数据来查找和理解
**** 组合性
** REST
Representational State Transfer
*** Web架构风格的一种
**** 松耦合性
**** 伸缩性
*** RESTful HTTP
**** 服务器
***** 资源是关键概念
每种资源拥有一个URI
****** 与客户端交互格式
******* XML
******* JSON
******* HMTL
******* 二进制数据
***** 无状态通信
****** 不同请求互相独立
****** 提高系统伸缩性
***** 可看做对象
****** 对象方法
******* GET
******* PUT
******* POST
******* DELETE
**** 客户端
***** 转移方式
****** 超媒体
HATEOAS : Hypermedia as the Engine of Application State
****** 服务器重定向
*** 和DDD联合方法
**** 为系统接口层单独创建限界上下文
通过适当的策略来访问实际的核心模型
***** 优先考虑
***** 适合专属系统
**** 使用标准媒体类型
***** 使用通用格式
e.g. ical
***** 本质：共享内核/发布语言
***** 适合通用系统
** CQRS
命令和查询职责分离 ： Comman-Query Responsiblity Segregation
*** 读写分离
**** 读模型 （查询模型）
***** 数据库视图（可实现）
**** 写模型 （命令模型）
***** 每个方法完成时发布领域事件
****** 不合法的命令将失败，不发布领域事件
***** 事件发布器
***** 事件订阅器
****** 更新查询模型
******* 同步
******* 异步
***** ETL
ORM持久化机制可用数据仓库的ETL转换结果
*** 客户端驱动命令处理
**** 客户端向服务器发送命令
**** 命令处理器（接收）
只完成有限的功能
***** 分类风格
categorized style
****** 根据命令类别来实现应用服务
****** 简单：易理解、创建、维护
***** 专属风格
dedicated style
****** 每种命令对应单独的类
****** 职责单一、互相独立
***** 消息风格
messaging style ，专属风格进一步发展
****** 每个命令通过异步消息发送
异步提高伸缩性
****** 最复杂
*** 处理最终一致性的查询模型
**** UI临时性显示先前提交给命令模型的参数
**** 显式地在UI上显示当前查询模型的时间
** EDA
   事件驱动架构
*** 管道与过滤器
*** 长时间处理过程（也叫Saga）
**** 需考虑时间敏感性
***** 被动超时检查
***** 主动超时检查
**** 最终一致性
*** 事件源
**** 事件存储
***** 快照
** 数据网织和基于网格的分布式计算
*** 数据复制
**** 内存数据库
*** 事件驱动网织
**** 支持开放架构
*** 持续查询
*** 分布式处理
